<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State</title>
</head>

<body>
    <!-- 准备好一个容器 -->
    <div id="test"></div>

    <!-- 引入 react 核心库 -->
    <script type="text/javascript" src="../js/react.development.js"></script>
    <!-- 引入 react-dom， 用于支持 react 操作 DOM -->
    <script type="text/javascript" src="../js/react-dom.development.js"></script>
    <!-- 引入 Babel，用于将 jsx 转换为 js -->
    <script type="text/javascript" src="../js/babel.min.js"></script>

    <script type="text/babel">
        // 1. 创建类式组件
        class Weather extends React.Component {
            
            // 借助构造器初始化状态
            // 构造器在每次生成新对象时被调用，生成了一个Weather对象，所以调用了一次
            constructor(props){
                super(props)
                // 构造器中的 this 就是实例对象
                // 初始化状态
                this.state = {isHot: true}
                this.changeWeather = this.changeWeather.bind(this) // bind做两件事，1.生成新的函数；2.修改了函数内部的this指向
            }

            // render调用了几次？ 1+n次，1: 初始化调用一次; n: 每次更新状态，render重新调用
            render() {
                // console.log(this)
                // 读取状态
                const {isHot} = this.state  //this.state.isHot
                return (
                    // 此处不能写onClick={changeWeather()}，
                    // 因为左边 onClick= 是一个赋值语句，右边changeWeather()是执行一个函数，并赋返回函数返回值
                    // <h2 id='title' onClick={()=>{this.changeWeather()}}>今天天气很{isHot ? '炎热' : '凉爽'}</h2>
                    <h2 id='title' onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}</h2>
                )
            }
            // changeWeather调用了几次？- 点击几次调几次
            changeWeather() {
                // changeWeather 方法放在了哪里？Weather类的原型对象上，供实例使用。
                // 通过 Weather 实例调用 changeWeather 时，changeWeather 中的 this 就是 Weather 实例。
                // 由于changeWeather 是作为onClickde 的回调，所以不是通过实例调用的，是直接调用。
                // 类中的方法默认开启了局部的严格模式，所以changeWeather 中的this为undefined。
                // console.log(this)
                const isHot = this.state.isHot
                
                // state 要用setState() 方法修改，setState要传入对象{}；且更新是一种合并merge操作（只修改传入的同名props值，其余值不变）
                this.setState({isHot: !isHot})
            }
        }
        
        // 2. 渲染组件到页面
        ReactDOM.render(<Weather/>, document.getElementById('test'))

        /* 
            总结：
                组件中 render方法中的this为组件的实例对象
                组件中的自定义方法中的this为undefined（作为回调函数的时候是undefined）， 如何解决？
                    1. 强制绑定this：通过函数对象的 bind()
                    2. 箭头函数

                严重注意：状态不可直接更改，this.state.isHot=!isHot 是错误写法
        */

/* // 不推荐使用
        const title = document.getElementById("title")
        title.addEventListener('click', ()=>{
            console.log('标题被点击了1')
        })
        title.onlick = ()=>{
            console.log('标题被点击了2')
        }
*/


    </script>
</body>

</html>